# frozen_string_literal: true

class SudoModeHandler
  # The default preference order for authentication factors (lower is better)
  # 0 is deliberately left available so we can use it for the user's preference
  FACTOR_PREFERENCES = {
    totp: 1,
    webauthn: 2,
    sms: 3,
    email: 4,
  }.freeze

  # @param controller_instance [ApplicationController]
  def initialize(controller_instance:)
    @controller_instance = controller_instance
  end

  def call
    if params[:_sudo] && params[:_sudo][:method]
      login = Login.incomplete.active.find_by_hashid!(params[:_sudo][:login_id])

      UserService::ExchangeLoginCodeForUser.new(
        user_id: current_user.id,
        login_code: params[:_sudo][:login_code],
        sms: false,
      ).run

      login.update!(authenticated_with_email: true)
      login.update!(user_session: current_session)

      current_session.reload
    else
      login = Login.create!(
        user: current_user,
        initial_login: current_session.initial_login
      )

      default_factor, *additional_factors = sorted_factors(login)

      # In the case where we know we're going to ask for an SMS or email code,
      # send it ahead of time so the user doesn't have to perform an additional
      # step
      if [:sms, :email].include?(default_factor)
        LoginCodeService::Request.new(
          email: current_user.email,
          sms: default_factor == :sms,
          ip_address: request.remote_ip,
          user_agent: request.user_agent
        ).run
      end

      # Remove extra content from the layout so we only have the
      # reauthentication form on the page.
      controller_instance.instance_variable_set(:@no_app_shell, true)

      controller_instance.render(
        template: "sudo_mode/reauthenticate",
        layout: "application",
        locals: {
          login:,
          additional_factors:,
          default_factor:,
          forwarded_params:
        },
        status: :unprocessable_entity
      )
    end
  end

  private

  attr_reader(:controller_instance)

  delegate(
    :current_user,
    :current_session,
    :params,
    :session,
    :request,
    to: :controller_instance,
    private: true
  )

  def sorted_factors(login)
    factor_preference = FACTOR_PREFERENCES

    # Put the user's preference first
    user_preference = params.dig(:_sudo, :switch_method).presence || session[:login_preference].presence
    if user_preference.present? && factor_preference.key?(user_preference.to_sym)
      factor_preference = factor_preference.merge(user_preference.to_sym => 0)
    end

    login.available_factors.sort_by { |factor| factor_preference.fetch(factor) }
  end

  # Extracts the request parameters as a flat list of key-value pairs (instead
  # of following Rack's nesting conventions) so that we can re-submit them along
  # with the sudo credentials.
  def forwarded_params
    Rack::Utils
      .parse_query(request.request_parameters.to_query)
      .reject do |name, _value|
        case name
        # Both of these fields will be regenerated by `form_tag`
        when "authenticity_token", "_method"
          true
        else
          # Skip anything that is part of the sudo functionality
          name.start_with?("_sudo")
        end
      end
  end

end
